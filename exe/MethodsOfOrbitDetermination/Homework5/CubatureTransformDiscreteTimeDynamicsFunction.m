function [propagated_state] = CubatureTransformDiscreteTimeDynamicsFunction(...
        state, ...
        state_parameters, ...
        time_parameters, ...
        gravity_parameters, ...
        drag_parameters, ...
        structure_parameters, ...
        integration_parameters)
    arguments(Input)
        state(:, :) double
        state_parameters(1, 1) struct
        time_parameters(1, 1) struct
        gravity_parameters(1, 1) struct
        drag_parameters(1, 1) struct
        structure_parameters(1, 1) struct
        integration_parameters(1, 1) struct
    end

    arguments(Output)
        propagated_state(:, :) double
    end

    % State should be size [num_states, N]
    assert(size(state, 1) == state_parameters.num_states);

    % Convert time to modified Julian date in seconds.
    start_time = integration_parameters.integration_start_time;
    end_time   = integration_parameters.integration_end_time;
    time_span  = [start_time, end_time];

    % Set up the dynamics function
    ode_45_dynamics_function = ...
        @(t, y) ODE45DynamicsFunction(...
            t, ...
            y, ...
            state_parameters, ...
            time_parameters, ...
            gravity_parameters, ...
            drag_parameters, ...
            structure_parameters);

    % ODE 45 requires the state to be a vector.
    state = state(:);

    % Integrate the state forward in time.
    [~, propagated_state_history] = ode45( ...
        ode_45_dynamics_function, ...
        time_span, ...
        state, ...
        integration_parameters.ode45_options);

    % Each stacked state is a row, and the final row is the final state. Extract it and reshape it.
    propagated_state = reshape(transpose(propagated_state_history(end, :)), state_parameters.num_states, []);

    % State should be size [num_states, N]
    assert(size(propagated_state, 1) == state_parameters.num_states);
end